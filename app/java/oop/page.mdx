import JavaCodeRunner from '@/components/java/JavaCodeRunner'
import { Quiz } from '@/components/Quiz'

# Object-Oriented Programming 🏗️

<div className="text-center py-6">
  <div className="text-6xl mb-4">🏗️</div>
  <h1 className="text-4xl font-bold bg-gradient-to-r from-amber-600 to-orange-600 bg-clip-text text-transparent mb-4">
    Object-Oriented Programming
  </h1>
  <p className="text-xl text-gray-600 max-w-2xl mx-auto">
    Build your own custom data types and create amazing object-oriented programs!
  </p>
</div>

---

## What is Object-Oriented Programming? 🤔

Object-Oriented Programming (OOP) is like building with LEGO blocks. Instead of just using simple variables, you create your own custom "blueprints" (classes) that can have properties and behaviors, then create objects from these blueprints.

## Creating Your First Class 🎯

<JavaCodeRunner
  code={`// Define a simple Car class
class Car {
    // Properties (instance variables)
    String brand;
    String model;
    int year;
    String color;
    
    // Constructor - special method to create objects
    public Car(String brand, String model, int year, String color) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        this.color = color;
    }
    
    // Methods (behaviors)
    public void start() {
        System.out.println("🚗 " + brand + " " + model + " is starting up!");
    }
    
    public void honk() {
        System.out.println("🔊 BEEP BEEP!");
    }
    
    public void displayInfo() {
        System.out.println("🚙 Car Info:");
        System.out.println("Brand: " + brand);
        System.out.println("Model: " + model);
        System.out.println("Year: " + year);
        System.out.println("Color: " + color);
    }
}

public class CarDemo {
    public static void main(String[] args) {
        // Creating objects (instances) of the Car class
        Car myCar = new Car("Toyota", "Camry", 2022, "Blue");
        Car friendsCar = new Car("Honda", "Civic", 2021, "Red");
        
        // Using the objects
        myCar.displayInfo();
        myCar.start();
        myCar.honk();
        
        System.out.println();
        friendsCar.displayInfo();
        friendsCar.start();
    }
}`}
/>

## Encapsulation - Protecting Your Data 🔒

<JavaCodeRunner
  code={`class BankAccount {
    // Private variables - can't be accessed directly from outside
    private String accountNumber;
    private double balance;
    private String owner;
    
    // Constructor
    public BankAccount(String accountNumber, String owner, double initialBalance) {
        this.accountNumber = accountNumber;
        this.owner = owner;
        this.balance = Math.max(0, initialBalance); // Ensure non-negative balance
    }
    
    // Public methods to interact with private data
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("💰 Deposited $" + amount);
            System.out.println("💳 New balance: $" + String.format("%.2f", balance));
        } else {
            System.out.println("❌ Invalid deposit amount!");
        }
    }
    
    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println("💸 Withdrew $" + amount);
            System.out.println("💳 New balance: $" + String.format("%.2f", balance));
        } else if (amount > balance) {
            System.out.println("❌ Insufficient funds!");
        } else {
            System.out.println("❌ Invalid withdrawal amount!");
        }
    }
    
    // Getter methods to access private data safely
    public double getBalance() {
        return balance;
    }
    
    public String getOwner() {
        return owner;
    }
    
    public String getAccountNumber() {
        return accountNumber;
    }
    
    public void displayAccountInfo() {
        System.out.println("🏦 Account Info:");
        System.out.println("Owner: " + owner);
        System.out.println("Account: " + accountNumber);
        System.out.println("Balance: $" + String.format("%.2f", balance));
    }
}

public class BankDemo {
    public static void main(String[] args) {
        BankAccount account = new BankAccount("12345", "Alice Johnson", 1000.0);
        
        account.displayAccountInfo();
        
        System.out.println();
        account.deposit(250.50);
        
        System.out.println();
        account.withdraw(100.0);
        
        System.out.println();
        account.withdraw(2000.0); // This should fail
        
        System.out.println();
        account.displayAccountInfo();
    }
}`}
/>

## Inheritance - Building on Existing Classes 📈

<JavaCodeRunner
  code={`// Base class (Parent/Superclass)
class Animal {
    protected String name;
    protected int age;
    
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void eat() {
        System.out.println("🍽️ " + name + " is eating.");
    }
    
    public void sleep() {
        System.out.println("😴 " + name + " is sleeping.");
    }
    
    public void makeSound() {
        System.out.println("🔊 " + name + " makes a sound.");
    }
    
    public void displayInfo() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}

// Derived class (Child/Subclass)
class Dog extends Animal {
    private String breed;
    
    public Dog(String name, int age, String breed) {
        super(name, age); // Call parent constructor
        this.breed = breed;
    }
    
    // Override parent method
    @Override
    public void makeSound() {
        System.out.println("🐕 " + name + " barks: Woof! Woof!");
    }
    
    // New method specific to Dog
    public void wagTail() {
        System.out.println("🐕 " + name + " is wagging its tail!");
    }
    
    @Override
    public void displayInfo() {
        super.displayInfo(); // Call parent method
        System.out.println("Breed: " + breed);
    }
}

class Cat extends Animal {
    private boolean isIndoor;
    
    public Cat(String name, int age, boolean isIndoor) {
        super(name, age);
        this.isIndoor = isIndoor;
    }
    
    @Override
    public void makeSound() {
        System.out.println("🐱 " + name + " meows: Meow! Meow!");
    }
    
    public void purr() {
        System.out.println("🐱 " + name + " is purring contentedly.");
    }
    
    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("Indoor cat: " + (isIndoor ? "Yes" : "No"));
    }
}

public class InheritanceDemo {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", 3, "Golden Retriever");
        Cat myCat = new Cat("Whiskers", 2, true);
        
        System.out.println("🐕 Dog Demo:");
        myDog.displayInfo();
        myDog.eat();
        myDog.makeSound();
        myDog.wagTail();
        
        System.out.println("\\n🐱 Cat Demo:");
        myCat.displayInfo();
        myCat.eat();
        myCat.makeSound();
        myCat.purr();
        
        // Polymorphism - treating different objects the same way
        System.out.println("\\n🔄 Polymorphism Demo:");
        Animal[] pets = {myDog, myCat};
        
        for (Animal pet : pets) {
            pet.makeSound(); // Calls the appropriate version for each animal
        }
    }
}`}
/>

## Static Members - Class-Level Properties 🌟

<JavaCodeRunner
  code={`class Student {
    // Instance variables (unique to each student)
    private String name;
    private int grade;
    
    // Static variables (shared by all students)
    private static int totalStudents = 0;
    private static String schoolName = "Java High School";
    
    public Student(String name, int grade) {
        this.name = name;
        this.grade = grade;
        totalStudents++; // Increment when a new student is created
    }
    
    // Instance method
    public void study() {
        System.out.println("📚 " + name + " is studying hard!");
    }
    
    // Static method (belongs to the class, not any specific instance)
    public static int getTotalStudents() {
        return totalStudents;
    }
    
    public static String getSchoolName() {
        return schoolName;
    }
    
    public static void schoolAnnouncement() {
        System.out.println("📢 Announcement from " + schoolName + ":");
        System.out.println("We currently have " + totalStudents + " enrolled students!");
    }
    
    public void displayInfo() {
        System.out.println("👨‍🎓 Student: " + name + " (Grade " + grade + ")");
    }
}

public class StaticDemo {
    public static void main(String[] args) {
        // Access static method without creating objects
        System.out.println("🏫 School: " + Student.getSchoolName());
        System.out.println("👥 Students enrolled: " + Student.getTotalStudents());
        
        System.out.println();
        
        // Create some students
        Student alice = new Student("Alice", 85);
        Student bob = new Student("Bob", 92);
        Student charlie = new Student("Charlie", 78);
        
        alice.displayInfo();
        bob.displayInfo();
        charlie.displayInfo();
        
        System.out.println();
        
        // Static method call
        Student.schoolAnnouncement();
        
        System.out.println();
        
        // Instance methods
        alice.study();
        bob.study();
        
        System.out.println("\\n📊 Final count: " + Student.getTotalStudents() + " students");
    }
}`}
/>

## Practice Challenge 🎯

<Quiz
  question="In OOP, what is encapsulation?"
  options={[
    "Creating objects from classes",
    "Hiding internal details and protecting data with private variables", 
    "One class inheriting from another",
    "Having multiple methods with the same name"
  ]}
  correctAnswer={1}
  explanation="Encapsulation is the OOP principle of hiding internal implementation details and protecting data by making variables private and providing public methods to access them safely."
/>

## Real-World Example: Library Management System 📖

<JavaCodeRunner
  code={`class Book {
    private String title;
    private String author;
    private boolean isCheckedOut;
    private String borrower;
    
    public Book(String title, String author) {
        this.title = title;
        this.author = author;
        this.isCheckedOut = false;
        this.borrower = null;
    }
    
    public boolean checkOut(String borrowerName) {
        if (!isCheckedOut) {
            isCheckedOut = true;
            borrower = borrowerName;
            System.out.println("📖 '" + title + "' checked out to " + borrowerName);
            return true;
        } else {
            System.out.println("❌ '" + title + "' is already checked out to " + borrower);
            return false;
        }
    }
    
    public void returnBook() {
        if (isCheckedOut) {
            System.out.println("📚 '" + title + "' returned by " + borrower);
            isCheckedOut = false;
            borrower = null;
        } else {
            System.out.println("❌ '" + title + "' was not checked out");
        }
    }
    
    public void displayStatus() {
        System.out.println("📕 " + title + " by " + author);
        if (isCheckedOut) {
            System.out.println("   Status: Checked out to " + borrower);
        } else {
            System.out.println("   Status: Available ✅");
        }
    }
    
    // Getters
    public String getTitle() { return title; }
    public boolean isAvailable() { return !isCheckedOut; }
}

class Library {
    private Book[] books;
    private int bookCount;
    
    public Library(int capacity) {
        books = new Book[capacity];
        bookCount = 0;
    }
    
    public void addBook(String title, String author) {
        if (bookCount < books.length) {
            books[bookCount] = new Book(title, author);
            bookCount++;
            System.out.println("➕ Added: " + title);
        } else {
            System.out.println("❌ Library is full!");
        }
    }
    
    public void displayAllBooks() {
        System.out.println("\\n📚 Library Catalog:");
        System.out.println("=" .repeat(40));
        for (int i = 0; i < bookCount; i++) {
            books[i].displayStatus();
        }
    }
    
    public Book findBook(String title) {
        for (int i = 0; i < bookCount; i++) {
            if (books[i].getTitle().equalsIgnoreCase(title)) {
                return books[i];
            }
        }
        return null;
    }
    
    public void checkOutBook(String title, String borrower) {
        Book book = findBook(title);
        if (book != null) {
            book.checkOut(borrower);
        } else {
            System.out.println("❌ Book '" + title + "' not found");
        }
    }
    
    public void returnBook(String title) {
        Book book = findBook(title);
        if (book != null) {
            book.returnBook();
        } else {
            System.out.println("❌ Book '" + title + "' not found");
        }
    }
}

public class LibraryDemo {
    public static void main(String[] args) {
        Library library = new Library(5);
        
        // Add books to library
        library.addBook("Java: The Complete Reference", "Herbert Schildt");
        library.addBook("Clean Code", "Robert Martin");
        library.addBook("Design Patterns", "Gang of Four");
        
        library.displayAllBooks();
        
        System.out.println("\\n🔄 Checking out books:");
        library.checkOutBook("Clean Code", "Alice");
        library.checkOutBook("Java: The Complete Reference", "Bob");
        
        library.displayAllBooks();
        
        System.out.println("\\n🔄 Trying to check out already borrowed book:");
        library.checkOutBook("Clean Code", "Charlie");
        
        System.out.println("\\n🔄 Returning books:");
        library.returnBook("Clean Code");
        
        library.displayAllBooks();
    }
}`}
/>

## OOP Principles Summary 📋

### 1. **Encapsulation** 🔒
- Hide internal details
- Use private variables
- Provide public methods for access

### 2. **Inheritance** 📈  
- Create new classes based on existing ones
- Share common functionality
- Override methods when needed

### 3. **Polymorphism** 🔄
- Same method name, different behaviors
- Objects can be treated as their parent type
- Runtime decides which method to call

### 4. **Abstraction** 🎭
- Focus on what an object does, not how
- Hide complex implementation details
- Provide simple interfaces

## Best Practices 💡

1. **Use meaningful class and method names**
2. **Keep classes focused on a single responsibility**
3. **Make variables private and provide getters/setters**
4. **Use inheritance when there's a true "is-a" relationship**
5. **Override toString() method for better object representation**
6. **Document your classes and methods**

## Next Steps 🚀

Congratulations! You've mastered the fundamentals of Object-Oriented Programming in Java. You now understand how to create classes, objects, and build complex systems using OOP principles.

Final step: **Java Assessment** - Time to put all your knowledge together! 🎯