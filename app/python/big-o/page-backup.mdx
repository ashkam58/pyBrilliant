import CartoonCard from "@/components/dsa/CartoonCard";

<StopwatchSim />


## Best, Average, Worst â€” Î©, Î˜, O


<CartoonCard emoji="ðŸ§­" title="Three Greek friends" subtitle="Omega (best), Theta (average), Bigâ€‘O (worst)">
When you linearly search a list, the **best** case finds the item first (Î©), the **average** is somewhere in the middle (Î˜), and the **worst** case is last (O). Interviewers usually ask for **Bigâ€‘O** â€” the worst case.
</CartoonCard>


<SearchSimulator />


## First graph: O(n)


If a loop runs *n* times, itâ€™s **O(n)** â€” work grows *proportionally* with *n*.


```python
# prints 0..n-1 â†’ n operations â†’ O(n)
for i in range(n):
print(i)
```


## Growth playground


<BigOBarPlot />


## Drop the constants (fashionably)


Two backâ€‘toâ€‘back loops doing similar work take **2n** ops, but Bigâ€‘O ignores constant factors. Shapes win, not shirts.


<DropConstantsDemo />


## Quick quiz


<QuizMCQ
question="If one algorithm does 500*n* operations and another does 3*n*, what are their Bigâ€‘O classes?"
choices={["O(500n) vs O(3n)", "Both O(n)", "O(n^2) vs O(n)", "O(log n) vs O(1)"]}
answer="Both O(n)"
explanation="Bigâ€‘O ignores constant multipliers; both are linear."
/>


<QuizMCQ
question="Linear search in the worst case touches how many items?"
choices={["1", "log n", "n", "n^2"]}
answer="n"
explanation="If the target is last or absent, you check the whole list."
/>


---


**Next stop:** Pointers & mutability â€” where arrows matter more than numbers.
