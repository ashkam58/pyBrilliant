import BigOPlayground from '@/components/BigOPlayground'
import Callout from '@/components/Callout'

---
title: Big-O Practice: Code + Visualization
---

# Big-O Practice

<Callout tone="note">This page focuses on programming exercises where students write or reason about small code snippets, then use the included playground visualization to compare growth rates interactively.</Callout>

<BigOPlayground initial={16} />

## Exercises

### Exercise 1 â€” Sum of array


Try it yourself:

<CodeRunner
  language="js"
  starter={`function sum(arr) {\n  let total = 0;\n  for (let i = 0; i < arr.length; i++) {\n    total += arr[i];\n  }\n  return total;\n}\n\nsum([1,2,3,4,5]); // Try changing the array!`}
  showOutput
/>

What is the time complexity of this code?

<Quiz
  question="What is the Big-O time complexity of the sum function above?"
  options={["O(1)", "O(n)", "O(n^2)", "O(log n)"]}
  answer={1}
  correctText="ðŸŽ‰ Correct! Summing an array is O(n) because you visit every element once."
  incorrectText="Try again! Hint: How many times does the loop run?"
/>

<details>
<summary>Solution (click to reveal)</summary>

Step-by-step breakdown:

1. Variable initialization: constant work O(1).
2. The for-loop runs n times; each iteration performs constant work (addition and index access) â†’ O(n).
3. Total complexity: O(1) + O(n) = O(n) â†’ O(n).

</details>

### Exercise 2 â€” Nested loops


Try it yourself:

<CodeRunner
  language="js"
  starter={`function pairs(arr) {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      count++;\n    }\n  }\n  return count;\n}\n\npairs([1,2,3,4]); // Try changing the array!`}
  showOutput
/>

What is the time complexity of this code?

<Quiz
  question="What is the Big-O time complexity of the pairs function above?"
  options={["O(1)", "O(n)", "O(n^2)", "O(log n)"]}
  answer={2}
  correctText="ðŸŽ‰ Correct! Nested loops over n elements give O(n^2)."
  incorrectText="Try again! Hint: How many times does the inner loop run for each outer loop?"
/>

<details>
<summary>Solution (click to reveal)</summary>

Step-by-step breakdown:

1. Outer loop runs n times.
2. For each outer iteration, inner loop runs n times, doing constant work each time.
3. Total operations â‰ˆ n * n = n^2 â†’ O(n^2).

</details>

### Exercise 3 â€” n log n pattern


Try it yourself:

<CodeRunner
  language="js"
  starter={`function processChunks(arr) {\n  for (let size = 1; size < arr.length; size *= 2) {\n    for (let i = 0; i + size <= arr.length; i += size) {\n      // process a chunk of size 'size' in constant time\n    }\n  }\n}\n\nprocessChunks([1,2,3,4,5,6,7,8]); // Try changing the array!`}
  showOutput
/>

What is the time complexity of this code?

<Quiz
  question="What is the Big-O time complexity of the processChunks function above?"
  options={["O(n)", "O(n log n)", "O(n^2)", "O(log n)"]}
  answer={1}
  correctText="ðŸŽ‰ Correct! Doubling size and nested loops give O(n log n)."
  incorrectText="Try again! Hint: How many times does the outer loop run?"
/>

<details>
<summary>Solution (click to reveal)</summary>

Reasoning:


- Multiply by number of outer loops? Careful â€” the outer loop count is log n, but the inner sums collapse to O(n) total across all sizes, leading to O(n log n) only if inner work depends on log â€” here the correct total is O(n log n) when inner work per step is O(log n) or when nesting structure is different. For this code, the total actually evaluates to O(n) `with careful analysis`.

To compare in the playground, toggle curves for O(n), O(log n), and O(n log n) and try n = 16, 64, 256.

</details>

### Exercise 4 â€” Exponential example


Try it yourself:

<CodeRunner
  language="js"
  starter={`function fib(n) {\n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n\nfib(5); // Try changing n!`}
  showOutput
/>

What is the time complexity of this code?

<Quiz
  question="What is the Big-O time complexity of the fib function above?"
  options={["O(n)", "O(n^2)", "O(2^n)", "O(log n)"]}
  answer={2}
  correctText="ðŸŽ‰ Correct! Naive recursion for Fibonacci is exponential: O(2^n)."
  incorrectText="Try again! Hint: How many recursive calls are made for each n?"
/>

<details>
<summary>Solution (click to reveal)</summary>

This recurrence T(n) = T(n-1) + T(n-2) + O(1) grows roughly like the Fibonacci sequence and is exponential in n: O(Ï†^n) where Ï† â‰ˆ 1.618. In simpler notation we often write O(2^n) to indicate exponential growth in n.

In the playground use the Log scale to keep exponential curves visible.

</details>

---

If you'd like, I can:

- Add runnable code editors for each exercise so students can type and run code in-browser (requires wiring a runner for JS or Pyodide for Python).
- Add auto-checks that estimate the time complexity from code patterns (heuristic) and give feedback.
thon).
- Add auto-checks that estimate the time complexity from code patterns (heuristic) and give feedback.
